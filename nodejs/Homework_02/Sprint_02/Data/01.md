# 1. Однопоточна модель

JavaScript у браузері — однопоточний, тобто виконує код послідовно, рядок за рядком. Але завдяки асинхронності він не блокує виконання програми, коли, наприклад, чекає відповіді від сервера.

# 2. Асинхронність забезпечують Web API браузера

Коли ти використовуєш асинхронні методи (наприклад, setTimeout, fetch, події DOM), вони передаються зовнішнім API браузера, які працюють у фоновому режимі поза потоком JS. Тобто ці методи реалізовані не у JS!!!!

### Приклади таких Web API:
- setTimeout, setInterval
- fetch, XMLHttpRequest
- WebSockets, Web Workers, Geolocation, тощо

# 3. Event Loop 

Коли асинхронна операція завершується, результат (наприклад, callback чи проміс) потрапляє до черги задач (callback queue або microtask queue), і event loop перевіряє:

> "Чи вільний основний потік? Якщо так — запускаю наступну задачу з черги."

# 4. Черги задач: macro vs micro

Є два типи черг:

- Macro-task queue — setTimeout, setInterval, I/O, події

- Micro-task queue — .then() з Promise, queueMicrotask, MutationObserver

Microtask-и мають вищий пріоритет — вони виконуються одразу після поточного коду, але до будь-яких macro-task.