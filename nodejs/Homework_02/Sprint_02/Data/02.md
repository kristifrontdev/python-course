# 1. Чим відрізняється event loop у Node.js та в браузері?

Event loop (цикл подій) в Node.js і в браузері (клієнтському JavaScript) працює за схожими принципами, але з важливими відмінностями через різне середовище виконання. У Node.js event loop (цикл подій) реалізується на базі бібліотеки libuv, яка забезпечує асинхронність і неблокуюче введення/виведення (I/O).

## libuv

Це C-бібліотека, що лежить в основі Node.js.

Вона відповідає за:

- таймери (setTimeout, setInterval),
- мережеві операції,
- роботу з файловою системою,
- неблокуюче I/O.

libuv надає цикл подій, який Node.js використовує для відкладеного запуску завдань (task queue).

Неблокуюче I/O (non-blocking I/O) — це підхід до обробки операцій введення/виведення (наприклад, читання файлів, запити до бази даних, мережеві запити), при якому програма не зупиняється, поки чекає на результат, а продовжує виконувати інший код.

**Простими словами:**

- Блокуюче I/O: чекає завершення операції, перш ніж рухатися далі.

- Неблокуюче I/O: ініціює операцію і одразу рухається далі, а коли операція завершиться — викликається callback або Promise.

# 2. Внутрішні фази event loop у Node.js

Event loop в Node.js має 6 основних фаз, які виконуються циклічно:

| Фаза                     | Що виконується                                            |
| ------------------------ | --------------------------------------------------------- |
| **1. Timers**            | Колбеки від `setTimeout`, `setInterval`                   |
| **2. Pending callbacks** | Системні колбеки, які були відкладені                     |
| **3. Idle, prepare**     | Внутрішні дії Node.js                                     |
| **4. Poll**              | Очікування нових I/O подій (наприклад, файлові, мережеві) |
| **5. Check**             | Виконання `setImmediate()`                                |
| **6. Close callbacks**   | Наприклад, `socket.on('close')`                           |


# 3. Черги задач (queues)

У Node.js є три рівні черг:

| Черга                | Що туди потрапляє                 | Пріоритет |
| -------------------- | --------------------------------- | --------- |
| `process.nextTick()` | Власна черга Node.js              | найвищий  |
| **Microtasks**       | `Promise.then`, `queueMicrotask`  | високий   |
| **Macrotasks**       | `setTimeout`, `setImmediate`, I/O | нижчий    |


# Як все це працює разом?

1. JS код виконується синхронно.
2. Асинхронні завдання передаються в libuv.
3. libuv ставить їх у відповідні черги.
4. Event loop обробляє фази одну за одною.
5. Між фазами виконуються microtasks і process.nextTick().

## process.nextTick

process.nextTick() — це внутрішня функція Node.js, яка дозволяє поставити функцію в спеціальну чергу мікрозавдань, яка виконується перед усіма іншими асинхронними операціями — навіть перед Promise.then().


## В чому різниця між process.nextTick() і Promise.then()?

| Критерій            | `process.nextTick()`          | `Promise.then()`      |
| ------------------- | ----------------------------- | --------------------- |
| Доступно в          | тільки в Node.js              | у Node.js та браузері |
| Пріоритет виконання | **Вищий**, навіть за проміси  | Трохи нижчий          |
| Черга               | окрема черга "nextTickQueue"  | "microtask queue"     |
| Використання        | системні речі, швидкі колбеки | асинхронна логіка     |


## setImmediate

setImmediate() — це специфічна для Node.js функція, яка дозволяє виконати колбек наступним циклом event loop'а, після завершення поточного I/O, але до будь-яких таймерів (setTimeout).

const fs = require('fs');

```js
fs.readFile(__filename, () => {
    setTimeout(() => console.log('timeout'), 0);
    setImmediate(() => console.log('immediate'));
});
```
Коли краще використовувати? Якщо хочеш відкласти виконання функції після поточного I/O.
